#!python
"""
Convert VCF data to wormtable.

TODO:document.

Implementation Note: We use bytes throughout the parsing process here for
a few reasons. Mostly, this is because it's much easier to deal with bytes
values within the C module, as we'd have to decode Unicode objects before 
getting string. At the same time, it's probably quite a bit more efficient 
to work with bytes directly, so we win both ways. It's a bit tedious making 
sure that all the literals have a 'b' in front of them, but worth the 
effort.

"""
from __future__ import print_function
from __future__ import division 

import wormtable as wt

import os
import sys

# VCF Fixed columns

CHROM = b"CHROM"
POS = b"POS"
ID = b"ID"
REF = b"REF"
ALT = b"ALT"
QUAL = b"QUAL"
FILTER = b"FILTER"
INFO = b"INFO"

CHROM_DESC = b"CHROM"
POS_DESC = b"POS"
ID_DESC = b"ID"
REF_DESC = b"REF"
ALT_DESC = b"ALT"
QUAL_DESC = b"QUAL"
FILTER_DESC = b"FILTER"
INFO_DESC = b"INFO"



# Special values in VCF
MISSING_VALUE = b"."

# Strings used in the header for identifiers
ID = b"ID"
DESCRIPTION = b"Description"
NUMBER = b"Number"
TYPE = b"Type"
INTEGER = b"Integer"
FLOAT = b"Float"
FLAG = b"Flag"
CHARACTER = b"Character"
STRING = b"String"

def vcf_column_factory(line, prefix=None):
    """
    Returns a column object suitable for encoding a vcf column described by the 
    specified meta-information line.
    """
    d = {}
    s = line[line.find(b"<") + 1: line.find(b">")]
    for j in range(3):
        k = s.find(b",")
        tokens = s[:k].split(b"=")
        s = s[k + 1:]
        d[tokens[0]] = tokens[1]
    tokens = s.split(b"=", 1)
    d[tokens[0]] = tokens[1]
    name = d[ID]
    if prefix is not None:
        name = prefix + b"_" + d[ID]
    description = d[DESCRIPTION].strip(b"\"")
    number = d[NUMBER]
    if number == b".":
        num_elements = 0 # 0 means variable 
    else:
        num_elements = int(number) 
    st = d[TYPE]
    if st == INTEGER:
        c = wt.IntegerColumn
        element_size = 2
    elif st == FLOAT: 
        c = wt.FloatColumn
        element_size = 4
    elif st == FLAG: 
        c = wt.IntegerColumn
        element_size = 1
        # There's an oddity here - the VCF file can specifiy that 
        # there's an unspecified number of flag values, but surely
        # it's 1. This is a possible source of problems.
        num_elements = 1
    elif st == CHARACTER: 
        c = wt.StringColumn
        element_size = 1
    elif st == STRING: 
        c = wt.StringColumn
        num_elements = 0 
        element_size = 1
    else:
        raise ValueError("Unknown VFC type:", st)
    col = c(name, description, num_elements, element_size)
    return col
   
class VCFSchemaGenerator(object):
    """
    Class that generates a database schema for a VCF file by parsing 
    the header.
    """
    def __init__(self, vcf_file):
        self.__version = -1.0
        self.__file = vcf_file
        self.__info_lines = [] 
        self.__genotype_lines = []
        self.__genotypes = None 
    
    def __parse_version(self, s):
        """
        Parse the VCF version number from the specified string.
        """
        tokens = s.split(b"v")
        if len(tokens) == 2:
            self.__version = float(tokens[1])

    def __parse_meta_information(self, line):
        """
        Processes the specified meta information line to obtain the values 
        of the various columns and their types.
        """
        if line.startswith(b"##INFO"):
            self.__info_lines.append(line)
        elif line.startswith(b"##FORMAT"):
            self.__genotype_lines.append(line)
        else:
            pass
            # Should we parse the FILTER values and make a proper enum 
            # column? Probably.

    def __parse_header_line(self, s):
        """
        Processes the specified header string to get the genotype labels.
        """
        self.__genotypes = s.split()[9:]

    def generate_schema(self):
        """
        Reads the header for this VCF file, constructing the database 
        schema and returning it. 
        """
        f = self.__file 
        s = f.readline()
        self.__parse_version(s)
        if self.__version < 4.0:
            raise ValueError("VCF versions < 4.0 not supported")
        while s.startswith(b"##"):
            self.__parse_meta_information(s)
            s = f.readline()
        self.__parse_header_line(s)
        # Get the fixed columns
        # TODO put in more realistic sizes and enums here.
        columns = [
            wt.StringColumn(CHROM, CHROM_DESC),
            wt.IntegerColumn(POS, POS_DESC, 1, 8),
            wt.StringColumn(ID, ID_DESC),
            wt.StringColumn(REF, REF_DESC, 1),
            wt.StringColumn(ALT, ALT_DESC),
            wt.FloatColumn(QUAL, QUAL_DESC, 1, 4),
            wt.StringColumn(FILTER, FILTER_DESC),
        ]
        for line in self.__info_lines:
            col = vcf_column_factory(line, INFO)
            columns.append(col)
        for genotype in self.__genotypes:
            for line in self.__genotype_lines:
                col = vcf_column_factory(line, genotype)
                columns.append(col)
        schema = wt.Schema(columns)
        return schema

def vcf_schema_factory(vcf_file):
    """
    Returns a schema for the specified VCF file.
    """
    with open(vcf_file, "rb") as f:
        sg = VCFSchemaGenerator(f)
        schema = sg.generate_schema()
    return schema


class VCFTableWriter(wt.TableWriter):
    """
    Class responsible for parsing a VCF file and creating a database. 
    """
    
    def build(self, vcf_file):
        """
        Builds the table.
        """
        # TODO add support for gzips and progress callbacks
        with open(vcf_file, "rb") as f:
            self._source_file = f 
            self.prepare()
            for line in self._source_file:
                self.process_line(line)
        self.finalise()
        
    
    def get_insertion_function(self, column, index):
        """
        Returns an insertion function for the specified column and index.
        """
        f = None
        if isinstance(column, wt.StringColumn):
            def f(encoded):
                self.update_row(index, encoded)
        elif isinstance(column, wt.IntegerColumn):
            if column.get_num_elements() == 1:
                def f(encoded):
                    v = int(encoded)
                    self.update_row(index, v)
            else:
                def f(encoded):
                    v = [int(s) for s in encoded.split(b",")]
                    self.update_row(index, v) 
        elif isinstance(column, wt.FloatColumn):
            if column.get_num_elements() == 1:
                def f(encoded):
                    self.update_row(index, float(encoded))
            else:
                def f(encoded):
                    v = [float(s) for s in encoded.split(b",")]
                    self.update_row(index, v)
        else:
            assert(False) 
        return f


    def prepare(self):
        """
        Prepares for parsing records by getting the database columns 
        ready and skipping the file header.
        """
        # Skip the header
        f = self._source_file
        s = f.readline()
        while s.startswith(b"##"):
            s = f.readline()
        # Get the genotypes from the header
        genotypes = s.split()[9:] 
        # Set up the insertion functions and name mappings.
        column_names = [c.get_name() for c in self._schema.get_columns()]
        self.__insertion_functions = [None for c in column_names] 
        all_fixed_columns = [CHROM, POS, ID, REF, ALT, QUAL, FILTER]
        j = 0
        self.__fixed_columns = []
        for name in all_fixed_columns: 
            if name in column_names:
                c = self._schema.get_column(name)
                f = self.get_insertion_function(c, j)
                self.__fixed_columns.append((j, f))
            j += 1
        self.__info_columns = {}
        self.__genotype_columns = [{} for g in genotypes]
        for name in column_names: 
            if b"_" in name:
                split = name.split(b"_")
                if split[0] == INFO:
                    c = self._schema.get_column(name)
                    j = column_names.index(name)
                    f = self.get_insertion_function(c, j)
                    info_name = split[1]
                    self.__info_columns[info_name] = f 
                else:
                    index = genotypes.index(split[0])
                    c = self._schema.get_column(name)
                    j = column_names.index(name)
                    f = self.get_insertion_function(c, j)
                    self.__genotype_columns[index][split[1]] = f 
    


        """
        # In the interest of efficiency, we want to split the columns 
        # up into the smallest possible lists so we don't have to 
        # put in as much effort searching for them.
        all_columns = dict((c.get_name(), c) for c in self._schema.get_columns())
        all_fixed_columns = [CHROM, POS, ID, REF, ALT, QUAL, FILTER]
        self._fixed_columns = []
        for j in range(len(all_fixed_columns)):
            name = all_fixed_columns[j]
            if name in all_columns:
                self._fixed_columns.append((all_columns[name], j))
        self._info_columns = {}
        self._genotype_columns = [{} for g in genotypes]
        for c in self._schema.get_columns():
            if b"_" in c.get_name():
                split = c.get_name().split(b"_")
                if split[0] == INFO:
                    name = split[1]
                    self._info_columns[name] = c
                else:
                    index = genotypes.index(split[0])
                    self._genotype_columns[index][split[1]] = c
    
        """



    def process_line(self, line):
        """
        Processes the specified VCF record and inserts the appropriate row.
        """
        l = line.split()
        for column_index, f in self.__fixed_columns:
            if l[column_index] != MISSING_VALUE:
                f(l[column_index])
        # Now process the info columns.
        for mapping in l[7].split(b";"):
            tokens = mapping.split(b"=")
            name = tokens[0]
            if name in self.__info_columns:
                f = self.__info_columns[name]
                #print("setting ", name, tokens)
                if len(tokens) == 2:
                    f(tokens[1])
                else:
                    f(1) # This is a Flag column.
        # Process the genotype columns. 
        j = 0
        fmt = l[8].split(b":")
        for genotype_values in l[9:]:
            tokens = genotype_values.split(b":")
            if len(tokens) == len(fmt):
                for k in range(len(fmt)):
                    if fmt[k] in self.__genotype_columns[j]:
                        f = self.__genotype_columns[j][fmt[k]]
                        #print("setting", fmt[k], ":", tokens[k])
                        f(tokens[k])
            elif len(tokens) > 1:
                # We can treat a genotype value on its own as missing values.
                # We can have skipped columns at the end though, which we 
                # should deal with properly. So, put in a loud complaint 
                # here and fix later.
                print("PARSING CORNER CASE NOT HANDLED!!! FIXME!!!!")
            j += 1
    
        #print("commiting row")
        self.commit_row()

    def _insert_rows(self):
        """
        Builds the database in opened file.
        """
        fixed_columns = self._fixed_columns
        info_columns = self._info_columns
        genotype_columns = self._genotype_columns
        for s in self._source_file:
            l = s.split()
            # Read in the fixed columns
            for col, index in fixed_columns:
                if l[index] != MISSING_VALUE:
                    self._insert_elements(col, l[index])
            """
            # Now process the info columns.
            for mapping in l[7].split(b";"):
                tokens = mapping.split(b"=")
                name = tokens[0]
                if name in info_columns:
                    col = info_columns[name]
                    if len(tokens) == 2:
                        self._insert_elements(col, tokens[1])
                    else:
                        # This is a Flag column.
                        self._row_buffer.insert_elements(col, [1])
            # Process the genotype columns. 
            j = 0
            fmt = l[8].split(b":")
            for genotype_values in l[9:]:
                tokens = genotype_values.split(b":")
                if len(tokens) == len(fmt):
                    for k in range(len(fmt)):
                        if fmt[k] in genotype_columns[j]:
                            col = genotype_columns[j][fmt[k]]
                            self._insert_elements(col, tokens[k])
                elif len(tokens) > 1:
                    # We can treat a genotype value on its own as missing values.
                    # We can have skipped columns at the end though, which we 
                    # should deal with properly. So, put in a loud complaint 
                    # here and fix later.
                    print("PARSING CORNER CASE NOT HANDLED!!! FIXME!!!!")
                j += 1
            """
            # Finally, commit the record.
            self.commit_row()

def main():

    if len(sys.argv) == 3: 
        homedir = sys.argv[1] 
        vcf_file = sys.argv[2]
        input_schema = os.path.join(homedir, "input_schema.xml")
        schema = vcf_schema_factory(vcf_file)
        #schema.show()
        schema.write_xml(input_schema)
        # In the command line tool we'll optionally stop here 
        # and allow the user to edit the schema. This means 
        # we don't have to generate the 'perfect' vcf schema.
        tw = VCFTableWriter(homedir, input_schema)
        #tw.set_cache_size(8 * 2**30) # 8 gigs - bigger is better
        tw.build(vcf_file)
        
    elif len(sys.argv) == 2:
        table = wormtable.Table(sys.argv[1])
        print("num rows = ", table.get_num_rows())
        v = 0
        for j in range(table.get_num_rows()):
            row = table.get_row(j)
            print("row", j)
            for k, v in row.items():
                print("\t", k, "->", v)
        table.close()
    else:
        print("nothing for here")


if __name__ == "__main__":
   main() 


