#!python
"""
Wormtable administration program.
"""
from __future__ import print_function
from __future__ import division 

import re
import sys
import argparse
import signal

import wormtable as wt




def add_index(table, colspec):
    print("adding index") 
    bin_widths = []
    column_names = [] 
    index = wt.Index(table, colspec)
    for c in colspec.split("+"): 
        col_name = c
        bin_width = 0
        m = re.search("\[.*\]$", c)
        if m is not None:
            g = m.group(0)
            col_name = c[:m.start(0)]
            bin_width = float(g.strip("[]"))
        col = table.get_column(col_name)
        index.add_key_column(col, bin_width)
    index.open("w")
    n = len(table) 
    f = None
    monitor = wt.ProgressMonitor(n, "rows")
    def progress(processed_rows):
        monitor.update(processed_rows)
    f = progress
    index.build(f, max(1, int(n / 1000)))
    monitor.finish()
    index.close()

def delete_index(table, index_name):
    index = wt.Index(table, index_name)
    index.delete()

def print_table(table, cols, index=None, min_value=None, max_value=None):
    cursor = table.cursor(cols, index)
    if min_value is not None:
        cursor.set_min(min_value)
    if max_value is not None:
        cursor.set_max(max_value)
    f = sys.stdout
    for row in cursor:
        s = ""
        for c, v in zip(cols, row): 
            s = s + c.format_value(v) + "\t"
        f.write(s + "\n")

class ProgramRunner(object):
    """
    Class responsible for running the program, managing output streams 
    etc.
    """
    def __init__(self, homedir):
        self.__homedir = homedir
        self.__table = wt.Table(homedir)
        if not self.__table.exists():
            self.error("Table '{0}' not found".format(homedir))
        self.__table.open("r")
        self.__index = None

    def open_index(self, name):
        """
        Opens the specified index name for reading.
        """
        self.__index = wt.Index(self.__table, name)
        if not self.__index.exists():
            self.error("Index '{0}' not found".format(name))
        self.__index.open("r")

    def format_size(self, n):
        """
        Returns a string formatting the specified value in bytes into a
        human readable format. Based on StackOverflow answer.
        """
        num = n 
        for x in ['bytes','KiB','MiB','GiB']:
            if num < 1024.0:
                return "%3.1f %s" % (num, x)
            num /= 1024.0
        return "%3.1f %s" % (num, 'TiB')

    def print_columns(self):
        """
        Print out the details of the columns in the table.
        """
        t = self.__table
        # get the max width for name
        max_name_width = 0
        for c in t.columns():
            n = len(c.get_name()) 
            if n > max_name_width:
                max_name_width = n
        fmt = "{0:>4}   {1:{name_width}} {2:<6} {3:>6}   {4:<6}   |   {5}"
        s = fmt.format("", "name", "type", "size", "n", "description",
                    name_width=max_name_width + 2)
        print("=" * (len(s) + 2))
        print(s)
        print("=" * (len(s) + 2))
        for c in t.columns():
            num_elements = c.get_num_elements()
            name = c.get_name()
            desc = c.get_description()
            s = fmt.format(c.get_position(), name, c.get_type_name(), 
                    c.get_element_size(), 
                    num_elements if num_elements > 0 else "var(1)", desc, 
                    name_width=max_name_width + 2)
            print(s)

    def print_details(self):
        """
        Prints out a summary of the details of this table and its indexes.
        """
        t = self.__table
        # print a summary of the table first
        print(t.get_homedir(), ":")
        print("\trows = \t", len(t))
        print("\tminimum row size = \t", 
                self.format_size(t.get_fixed_region_size()))
        print("\tfile size = \t", self.format_size(t.get_db_file_size()))
        print("Indexes:") 
        indexes = []
        max_name_width = 0
        for i in t.indexes():
            i.open("r")
            indexes.append(i)
            n = len(i.get_name()) 
            if n > max_name_width:
                max_name_width = n
        max_name_width += 2
        fmt = "{0:{name_width}} {1:>10} {2:>3} | {3}" 
        s = fmt.format("name", "size", "n", "colspec", name_width=max_name_width)
        print("=" * (len(s) + 2))
        print(s)
        print("=" * (len(s) + 2))
        for i in indexes:
            s = fmt.format(i.get_name(), self.format_size(i.get_db_file_size()),
                    len(i.key_columns()), i.get_name(), name_width=max_name_width)
            print(s)
        for i in indexes:
            i.close()

    def print_histogram(self):
        counter = self.__index.counter()
        cols = self.__index.key_columns()
        n = len(cols)
        s = "\t".join([cols[j].get_name() for j in range(n)])
        s = "n\t" + s 
        print("#", s)
        for k, v in counter.items():
            if n == 1:
                s = cols[0].format_value(k) 
            else:
                s = "\t".join([cols[j].format_value(k[j]) for j in range(n)])
            print(v, "\t",  s)


    def error(self, s):
        """
        Raises and error and exits.
        """
        print("Error:", s)
        sys.exit(1) 


###########################

# Command entry points 

###########################

def ls(args):
    pr = ProgramRunner(args.HOMEDIR)
    pr.print_details()

def show(args):
    pr = ProgramRunner(args.HOMEDIR)
    pr.print_columns()

def hist(args):
    pr = ProgramRunner(args.HOMEDIR)
    pr.open_index(args.NAME)
    pr.print_histogram()


def add(args):
    with wt.open_table(args.HOMEDIR) as t:
        add_index(t, args.COLSPEC)



def remove(args):
    with wt.open_table(args.HOMEDIR) as t:
        delete_index(t, args.NAME)

 

def dump(args):
    """
    Dumps the entire table to stdout.
    """
    with wt.open_table(args.HOMEDIR) as t:
        min_value = None
        max_value = None
        # get the index, if there is one
        index = None
        if args.index is not None:
            index = wt.Index(t, args.index) 
            index.open("r")
            if args.min is not None:
                min_value = float(args.min)
            if args.max is not None:
                max_value = float(args.max)
        else:
            if args.min is not None:
                min_value = int(args.min)
            if args.max is not None:
                max_value = int(args.max)
        # get the columns
        cols = []
        all_columns = t.columns()
        if len(args.columns) == 0:
            cols = all_columns 
        else:
            for col_id in args.columns:
                c = None
                try: 
                    j = int(col_id)
                    c = all_columns[j]
                except ValueError:
                    c = t.get_column(col_id)
                cols.append(c)
        
        print_table(t, cols, index, min_value, max_value)
        
        if index is not None:
            index.close()

def add_homedir_argument(parser):
    """
    Adds a positional homedir argument to the specified parser.
    """
    parser.add_argument("HOMEDIR", 
        help="Wormtable home directory")   

def add_colspec_argument(parser):
    """
    Adds a positional colspec argument to the specified parser.
    """
    parser.add_argument("COLSPEC", 
        help="Column specification for the index.")   


def main():
    prog_description = "Wormtable administration program."
    parser = argparse.ArgumentParser(description=prog_description) 
    subparsers = parser.add_subparsers(title='subcommands',)
   
    # help 
    show_parser = subparsers.add_parser("help", 
            description = "wtadmin help",
            help="show this help message and exit")
    
    # show command
    show_parser = subparsers.add_parser("show", 
            description = "Show the columns in the table",
            help="show details about the columns in the table")
    add_homedir_argument(show_parser)
    show_parser.set_defaults(func=show)
    
    # dump command
    dump_parser = subparsers.add_parser("dump", 
            help="dump the table to stdout")
    add_homedir_argument(dump_parser)
    dump_parser.add_argument("columns", metavar="COLUMN", nargs="*", 
        help="Columns to dump - defaults to all columns")   
    dump_parser.add_argument("--cache-size", "-c", default="64M",
            help="cache size in bytes; suffixes K, M and G also supported.")   
    dump_parser.add_argument("--index", "-i", default=None,
            help="index to sort by when dumping rows")
    dump_parser.add_argument("--min", "-m", default=None,
            help="minimum value to print")
    dump_parser.add_argument("--max", "-x", default=None,
            help="maximum value to print")
    dump_parser.set_defaults(func=dump)
    
    # ls command
    ls_parser = subparsers.add_parser("ls", 
            help="list the indexes in the table")
    add_homedir_argument(ls_parser)
    ls_parser.set_defaults(func=ls)

    # add index command
    add_parser = subparsers.add_parser("add", 
            help="add a new index to the table")
    add_homedir_argument(add_parser)
    add_colspec_argument(add_parser)
    add_parser.add_argument("--progress", "-p", action="store_true", default=False,
        help="show progress monitor")   
    add_parser.add_argument("--force", "-f", action="store_true", default=False,
        help="force over-writing of existing index")   
    add_parser.add_argument("--name", "-n", 
        help="name of the index (defaults to COLSPEC)")
    add_parser.add_argument("--read-cache-size", "-c", default="64M",
            help="read cache size in bytes; suffixes K, M and G also supported.")   
    add_parser.add_argument("--write-cache-size", "-w", default="64M",
            help="write cache size in bytes; suffixes K, M and G also supported.")   
    add_parser.set_defaults(func=add) 
    
    # rm index command
    remove_parser = subparsers.add_parser("rm", help="delete an index")
    add_homedir_argument(remove_parser)
    remove_parser.add_argument("NAME", help="name of the index")
    remove_parser.set_defaults(func=remove) 

    # index histogram command 
    hist_parser = subparsers.add_parser("hist", help="""
        Show the histogram for index NAME""")
    add_homedir_argument(hist_parser)
    hist_parser.add_argument("NAME", help="name of the index")
    hist_parser.set_defaults(func=hist) 

    # Set signal handler for SIGPIPE to quietly kill the program.
    signal.signal(signal.SIGPIPE, signal.SIG_DFL)
    
    args = parser.parse_args()
    if "func" not in args:
        parser.print_help()
    else:
        args.func(args) 
        

if __name__ == "__main__":
    main()
