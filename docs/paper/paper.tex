%% BioMed_Central_Tex_Template_v1.05
%%                                      %
%  bmc_article.tex            ver: 1.05 %
%                                       %


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                     %%
%%  LaTeX template for BioMed Central  %%
%%     journal article submissions     %%
%%                                     %%
%%         <27 January 2006>           %%
%%                                     %%
%%                                     %%
%% Uses:                               %%
%% cite.sty, url.sty, bmc_article.cls  %%
%% ifthen.sty. multicol.sty		       %%
%%									   %%
%%                                     %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                 %%	
%% For instructions on how to fill out this Tex template           %%
%% document please refer to Readme.pdf and the instructions for    %%
%% authors page on the biomed central website                      %%
%% http://www.biomedcentral.com/info/authors/                      %%
%%                                                                 %%
%% Please do not use \input{...} to include other tex files.       %%
%% Submit your LaTeX manuscript as one .tex document.              %%
%%                                                                 %%
%% All additional figures and files should be attached             %%
%% separately and not embedded in the \TeX\ document itself.       %%
%%                                                                 %%
%% BioMed Central currently use the MikTex distribution of         %%
%% TeX for Windows) of TeX and LaTeX.  This is available from      %%
%% http://www.miktex.org                                           %%
%%                                                                 %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\NeedsTeXFormat{LaTeX2e}[1995/12/01]
\documentclass[10pt]{bmc_article}    



% Load packages
\usepackage{cite} % Make references as [1-4], not [1,2,3,4]
\usepackage{url}  % Formatting web addresses  
\usepackage{ifthen}  % Conditional 
\usepackage{multicol}   %Columns
\usepackage[utf8]{inputenc} %unicode support
%\usepackage[applemac]{inputenc} %applemac support if unicode package fails
%\usepackage[latin1]{inputenc} %UNIX support if unicode package fails
\urlstyle{rm}
 
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	
%%                                             %%
%%  If you wish to display your graphics for   %%
%%  your own use using includegraphic or       %%
%%  includegraphics, then comment out the      %%
%%  following two lines of code.               %%   
%%  NB: These line *must* be included when     %%
%%  submitting to BMC.                         %% 
%%  All figure files must be submitted as      %%
%%  separate graphics through the BMC          %%
%%  submission process, not included in the    %% 
%%  submitted article.                         %% 
%%                                             %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                     


\def\includegraphic{}
\def\includegraphics{}



\setlength{\topmargin}{0.0cm}
\setlength{\textheight}{21.5cm}
\setlength{\oddsidemargin}{0cm} 
\setlength{\textwidth}{16.5cm}
\setlength{\columnsep}{0.6cm}

\newboolean{publ}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                              %%
%% You may change the following style settings  %%
%% Should you wish to format your article       %%
%% in a publication style for printing out and  %%
%% sharing with colleagues, but ensure that     %%
%% before submitting to BMC that the style is   %%
%% returned to the Review style setting.        %%
%%                                              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 

%Review style settings
\newenvironment{bmcformat}{\begin{raggedright}\baselineskip20pt\sloppy\setboolean{publ}{false}}{\end{raggedright}\baselineskip20pt\sloppy}

%Publication style settings
%\newenvironment{bmcformat}{\fussy\setboolean{publ}{true}}{\fussy}



% Begin ...
\begin{document}
\begin{bmcformat}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                          %%
%% Enter the title of your article here     %%
%%                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Processing genome scale tabular data with wormtable}
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                          %%
%% Enter the authors here                   %%
%%                                          %%
%% Ensure \and is entered between all but   %%
%% the last two authors. This will be       %%
%% replaced by a comma in the final article %%
%%                                          %%
%% Ensure there are no trailing spaces at   %% 
%% the ends of the lines                    %%     	
%%                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\author{Jerome Kelleher\correspondingauthor%
       \email{Jerome Kelleher\correspondingauthor - jerome.kelleher@ed.ac.uk}%
      \and
         Rob W Ness
         \email{Rob W Ness - rob.ness@ed.ac.uk}%
       and 
         Daniel L Halligan%
         \email{Daniel L Halligan - dan.halligan@gmail.com}%
      }
      

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                          %%
%% Enter the authors' addresses here        %%
%%                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\address{%
    University of Edinburgh, King's Buildings, West Mains Road, %
        EH9 3JT, UK}%

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                          %%
%% The Abstract begins here                 %%
%%                                          %%
%% The Section headings here are those for  %%
%% a Research article submitted to a        %%
%% BMC-Series journal.                      %%  
%%                                          %%
%% If your article is not of this type,     %%
%% then refer to the Instructions for       %%
%% authors on http://www.biomedcentral.com  %%
%% and change the section headings          %%
%% accordingly.                             %%   
%%                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{abstract}
        % Do not use inserted blank lines (ie \\) until main body of text.
        \paragraph*{Background:} 
      Biological research generates large amounts of tabular data.
These tables are produced by 
programs and exported to plain text files, which are often very large. 
Researchers must process these files 
line-by-line, parsing values encoded as text into native types so that 
calculations may be done. This is a time consuming process.
Furthermore, there is no simple means of indexing these files so that 
rows containing particular values can be quickly found. 
\paragraph*{Results:} 
We introduce a new 
data format and software library called wormtable, which provides efficient 
access to tabular data in Python. Wormtable stores data in a compact
binary format, provides random access to rows, and enables sophisticated
indexing on columns within these tables. 

\paragraph*{Conclusions:} Using wormtable's simple API users 
can process tables in a very high performance manner, allowing them
much greater freedom to explore their data. 
Since it is no longer necessary to parse complex files,
data analysis code is also much simpler and less error prone. 
\end{abstract}



\ifthenelse{\boolean{publ}}{\begin{multicols}{2}}{}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                          %%
%% The Main Body begins here                %%
%%                                          %%
%% The Section headings here are those for  %%
%% a Research article submitted to a        %%
%% BMC-Series journal.                      %%  
%%                                          %%
%% If your article is not of this type,     %%
%% then refer to the instructions for       %%
%% authors on:                              %%
%% http://www.biomedcentral.com/info/authors%%
%% and change the section headings          %%
%% accordingly.                             %% 
%%                                          %%
%% See the Results and Discussion section   %%
%% for details on how to create sub-sections%%
%%                                          %%
%% use \cite{...} to cite references        %%
%%  \cite{koon} and                         %%
%%  \cite{oreg,khar,zvai,xjon,schn,pond}    %%
%%  \nocite{smith,marg,hunn,advi,koha,mouse}%%
%%                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%
%% Background %%
%%
\section*{Background} 

\emph{The Background section should be written in a
way that is accessible to researchers without specialist knowledge in
that area and must clearly state - and, if helpful, illustrate - the
background to the research and its aims. It should clearly described the
relevant context and the specific issue which the software described is
intended to address.}

Despite the ever increasing volumes of data being processed in bioinformatics,
the methods used are almost entirely based on plain text files. Data is 
usually encoded in lines of text, with each row consisting of a series of tab-delimited 
values.
These files are easy to view and interpret and can be processed on 
any platform with the minimum of library dependencies. Using compression,
text files can be quite compact, and Tabix~\cite{li11} provides  
fast retrieval of rows from arbitrary locations in the table.

It is not sufficient, however, to simply store and retrieve data. To use data
it must be \emph{processed}. This is the major flaw in 
using text files as a data format: before we can perform calculations, we 
must first parse the encoded information into native 
machine values. This is an expensive process, and 
compression (if it is used) adds another substantial overhead. The result 
of this is that simple calculations over a large dataset may take 
many hours to complete.

Another problem with tables stored text files is that it is difficult 
to index the information within particular columns. 
This means that most operations on a table require a complete scan 
through the file. As a result, the only viable means of 
working with a subset of the data
is to create another file consisting of the subset of interest. 
This is inflexible and error prone, and multiplies already significant  
storage requirements.

The obvious solution to these problems is to load tabular data into a
relational database. Databases store values in binary form so that parsing is 
not required, and support efficient retrieval and indexing. There 
are many problems with this approach, however. Relational databases are 
extremely complex systems, each supporting different features and SQL 
dialects. It is not a straightforward task to design a schema for a 
particular data set, particularly not if portability across different 
databases is required. Similarly, accessing the data requires a knowledge
of SQL. In the most common case, a database server must also be maintained
and so storage and user permissions must be carefully managed. All of 
these aspects require significant expertise.

A relational database server, however, is far more than we require in the 
majority of cases. Data files are usually written once and 
not subsequently expected to change.
Thus, storing this information 
in a relational database with its sophisticated concurrency control
is entirely unnecessary. Centralised storage of data sets
creates an unnecessary administration burden, as does an extra
layer of user management. Therefore, although relational databases
provide powerful data management technologies, they are complex
to use and maintain and are therefore rarely used for 
static datasets.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Implementation 
%%
\section*{Implementation}
\emph{This should include a description of the overall architecture of the software implementation, 
along with details of any critical issues and how they were addressed.
}

% what is wormtable?
Wormtable (write-once read-many table) 
is a new data format and software library designed specifically
to deal with the challenges of data processing in bioinformatics.
It provides a portable, compact, read-only store for tabular
data of essentially unlimited size. Tables can
be either written directly via the library, or converted
from existing formats via command line tools. 
Wormtable provides a simple Python API to access rows
in the table, facilitating efficient and convenient access to 
data. The core data manipulation and storage facilities 
are written in C for efficiency.

% Wormtable's binary row format 
Data is stored in rows using a  
compact binary format designed specifically for biological applications.
Each row consists of a fixed number of columns, and each column 
holds either a fixed or variable number of elements of a fixed type and size.
Wormtable currently supports signed and unsigned integers, 
floating point and character data. To store data as 
compactly as possible, integer sizes range from one to eight bytes,
and real numbers are stored as IEEE half, single, and double 
precision floating point values. 
Fixed and variable length character strings 
are also supported. 

% Tables
Rows are stored sequentially in a data file, and the offset and length 
of each row is stored in a Berkeley DB~\cite{obs99} database. 
Thus, any given row can be found 
by first looking up the database for its offset and length, and by then reading
the required set of bytes from the data file. 
Berkeley DB is a free and open-source embedded database toolkit that provides a
scalable key-value store. It is a mature and stable platform, 
and is currently the most widely deployed database toolkit in the 
world~\cite{sb12}. 

% Indexes
Besides random access to rows, wormtable also provides indexes
over arbitrary combinations of columns. An index is a database in 
which the keys are the values from the columns in question concatenated
together, and the values are pointers to the original row. Indexes make
many operations much more efficient, since we can directly seek to the 
rows we are interested in without performing a full table scan. They also 
provide a very efficient means of calculating a histogram for a given 
set of columns.

% Layout 
Each table corresponds to a directory in the file system
which is used to store the data files, indexes and metadata.
Files within a table's home directory are not intended to be 
manipulated by users, and the \texttt{wtadmin} program is provided 
to perform administration tasks such as adding and removing 
indexes. This approach is 
very flexible, since no centralised storage is required and 
tables can be moved around and between systems at will.
Tables are portable across operating systems and hardware
architectures.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Results and Discussion %%
%%
\section*{Results}

\emph{The Results and Discussion may be combined into a single section or
presented separately. They may also be broken into subsections with
short, informative headings. In any case what should be described is the
functionality of the software together with data on how its performance
and functionality compare with and improve on functionally similar
existing software. There should then be a discussion of the intended
use of the software, and the benefits that are envisioned together,
if possible, with an outline for the planned future development of
new features.}

\subsection*{API}
The principle goal of wormtable is to provide efficient access to data 
using a simple interface. The \texttt{Table} class provides the main interface,
and implements the standard Python sequence protocols. Efficient 
iteration over rows is provided by the \texttt{cursor} method, 
which takes as an argument the list of columns to read (similar to 
a select list in SQL). Only the values for the columns 
of interest are then retrieved, leading to considerable
time savings.
Providing an index as an argument to the \texttt{cursor} function
results in the rows being visited in the order defined by the 
index. The arguments \texttt{start} and \texttt{stop} 
then stipulate the range of values we are interested in.
There are several other useful classes and methods, but 
the \texttt{cursor} method encapsulates the core functionality
of wormtable: efficient iteration over rows.

The interface is kept as
simple and similar to the Python standard library as possible,
to ensure that there is little difficulty in learning the API.
Similarly, although one can readily imagine defining a 
query language using these 
primitive operations, we have deliberately avoided doing so. Adding 
an SQL-like query language would greatly increase the complexity 
of wormtable, and would only serve to raise the barrier to entry.
Less experienced programmers 
do not need to learn a query language to process data 
in a very high performance manner.

\subsection*{Examples}
The Variant Call Format (VCF) encodes information about variant sites in a genome 
as tab-delimited rows in a text file~\cite{da+11}.  
To illustrate the advantages of wormtable, we
converted a large 
publicly available VCF file, produced as part of the
Drosophila genetic reference panel~\cite{mr+12}, to wormtable format.
This VCF\cite{freeze.vcf}
consists of 15GB of uncompressed text and contains data from the 
whole genome over 6,146,611 rows.
Using the included \texttt{vcf2wt} program
the VCF was converted to wormtable format 
on a standard workstation with a single hard disk. The
conversion required approximately 69 minutes, and the size of the resulting  
wormtable was 10GB (using the smallest type required
to represent the data in each column).

Values are stored in wormtable in a portable binary format, so that no parsing is
required when reading in rows. To illustrate this advantage, we
wrote a script to count the number of transitions and transversions
in the dataset using wormtable and PyVCF~\cite{pyvcf}
a Python VCF parser.
In this example we proceed 
row-by-row, examining the REF and ALT columns and
counting the transitions and transversions we encounter. 
Using PyVCF this required approximately 126 minutes;
the wormtable version required
57 seconds. To compare against methods that are known to be extremely
efficient, we repeated the same 
example using the Unix tools \texttt{cut}, \texttt{grep} 
and \texttt{awk},  which required 80 seconds. Both the
Unix pipeline and wormtable were limited by the sequential read
bandwidth of the hard drive, and would therefore be much 
faster using modern solid state storage.
It should be noted, however, that although Unix 
pipelines are efficient, it is a difficult and error prone method 
of processing data when more complex calculations are required.

Another advantage of wormtable is the ability to create 
an index over arbitrary combinations of columns within a table.
Indexes make many operations much more efficient, as they provide 
a way to quickly find particular rows and avoid the 
heavy cost of a full table scan.
To illustrate this advantage, we repeated the example 
of counting transitions and transversions using an index 
on the REF and ALT columns.
The index required 3m40s to build and 
consumed 66MB of storage space. Counting the number of 
transitions and transversions using this index required 
less than a second.


\section*{Discussion}
It is well known that parsing text files is a very inefficient process, 
and binary file formats are preferable for this reason. BCF,
for example, is a binary version of the VCF format discussed above which 
is designed to avoid just this problem. There are significant difficulties,
however, with having many different binary file formats for bioinformatics 
data. Each binary format requires a library and set of tools to view 
and process it, as it is not reasonable to expect users to decode binary
files. Bindings for several different languages must also be provided, if 
the file format is to be widely used.
Maintaining these libraries, tools and language bindings across 
different processor architectures and operating systems
is a complex software engineering task. Maintaining this ecosystem 
separately for several different file formats is surely 
unsustainable.

Wormtable alleviates the need for these different formats and libraries,
as it is flexible enough to store many different types of data. Wormtable is portable,
and has been tested on big- and little-endian platforms with 32 and 64
bit word sizes, along with many operating system combinations. To 
take advantage of the advanced data processing features of wormtable
all that is required is a conversion program, a considerably simpler
task than designing and supporting a custom binary file format.

The library supports efficient access to any data stored in 
wormtable format, but there is currently a conversion tool for
the VCF format only. The most important aspect of future development 
is to develop tools to convert other tabular formats such as 
PSL, GFF, and SAM to wormtable format [Dan, Rob: does this make sense?
are there other formats we should chuck in here?]. 

Other probable directions for future development of wormtable 
are to incorporate data file compression; to develop a 
C library and bindings for other popular languages such as 
Perl and R; and to generally enrich the API with features useful 
to the community. It is difficult to predict the 
precise direction of future development since this depends 
on community involvement.  Wormtable is an open and 
collaborative project, actively seeking feedback and 
contributors.


%%%%%%%%%%%%%%%%%%%%%%
\section*{Conclusions}
\emph{This should state clearly the main conclusions of the article and give a clear 
explanation of the importance and relevance of the software.}

The volumes of data being produced and processed in bioinformatics are constantly 
increasing, but the tools available to end users to 
process this data are still mostly based on parsing plain text. This 
approach is very inefficient, and leads to several undesirable outcomes.
Firstly, and most obviously, a researcher's productivity is inevitably
reduced by having to wait for several hours to see the result of a 
simple calculation. There are also some less obvious consequences:
code quality is reduced, since testing over the entire dataset is 
infeasible, and it is much less likely that the effects of 
changing arbitrary quality thresholds (for example) will be 
systematically examined.

Wormtable is not intended to replace text files as the universal 
interchange format for biological data. 
It is intended to provide a persistent data structure 
that can be efficiently processed 
and searched. Using this data structure, researchers with no knowledge of 
database systems can take full advantage of sophisticated 
data management techniques, and write simple code to process 
data in a high performance manner. 
Different file formats can be handled consistently 
in wormtable, reducing the need for third party libraries 
to parse complex files and simplifying the code required 
to process data.
Together, these advantages of increased performance and reduced 
code complexity can substantially increase a researcher's 
productivity and ability to explore their data.


  
%%%%%%%%%%%%%%%%%%
\section*{Availability and requirements}
\paragraph{Project name:} Wormtable.
\paragraph{Project home page:}\url{https://pypi.python.org/pypi/wormtable}
\paragraph{Operating system(s):} POSIX.
\paragraph{Programming language:} C, Python.
\paragraph{Other requirements:} Berkeley DB 4.8 or later.
\paragraph{License:} GNU GPLv3+.
\paragraph{Any restrictions to use by non-academics:} None.

    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Authors contributions}
    Text for this section \ldots


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Acknowledgements}
  \ifthenelse{\boolean{publ}}{\small}{}
We would like to thank the Ashworth Codemonkeys for valuable feedback on earlier
versions of wormtable.  JK is supported by EPSRC grant EP/I013091/1.

 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                  The Bibliography                       %%
%%                                                         %%              
%%  Bmc_article.bst  will be used to                       %%
%%  create a .BBL file for submission, which includes      %%
%%  XML structured for BMC.                                %%
%%                                                         %%
%%                                                         %%
%%  Note that the displayed Bibliography will not          %% 
%%  necessarily be rendered by Latex exactly as specified  %%
%%  in the online Instructions for Authors.                %% 
%%                                                         %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


{\ifthenelse{\boolean{publ}}{\footnotesize}{\small}
 \bibliographystyle{bmc_article}  % Style BST file
  \bibliography{paper.bib} }     % Bibliography file (usually '*.bib' ) 

%%%%%%%%%%%

\ifthenelse{\boolean{publ}}{\end{multicols}}{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               %%
%% Figures                       %%
%%                               %%
%% NB: this is for captions and  %%
%% Titles. All graphics must be  %%
%% submitted separately and NOT  %%
%% included in the Tex document  %%
%%                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% Do not use \listoffigures as most will included as separate files


\end{bmcformat}
\end{document}







