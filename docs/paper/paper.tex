\documentclass{bioinfo}

% Bioinformatics definitions.

\copyrightyear{2013}
\pubyear{2013}

\begin{document}
\firstpage{1}

\title[Wormtable]{Wormtable: A data structure for genome scale data}
\author[Kelleher \textit{et~al}]{Jerome Kelleher, Rob W. Ness 
and Daniel L. Halligan}
\address{
University of Edinburgh,
King's Buildings,
West Mains Road,
EH9 3JT,
UK
}

\history{Received on XXXXX; revised on XXXXX; accepted on XXXXX}

\editor{Associate Editor: XXXXXXX}

\maketitle

\begin{abstract}
\section{Summary:}
Biological research generates large amounts of tabular data.
These tables are produced by 
programs and exported to plain text files, which are often very large. 
Researchers must process these files 
line-by-line, parsing values encoded as text into native types so that 
calculations may be done. This is a time consuming process.
Furthermore, there is no simple means of indexing these files so that 
rows containing particular values can be quickly found. We introduce a new 
data format and software library called wormtable, which provides efficient 
access to tabular data in Python. Wormtable stores data in a compact
binary format, provides random access to rows, and enables sophisticated
indexing on columns within these tables. 
\section{Availability:}
Package available at 
\href{http://pypi.python.org/pypi/wormtable}{http://pypi.python.org/pypi/wormtable}

\section{Contact:} \href{jerome.kelleher@ed.ac.uk}{jerome.kelleher@ed.ac.uk}
\end{abstract}

\section{Introduction}
Despite the ever increasing volumes of data being processed in bioinformatics,
the methods used are almost entirely based on plain text files. Data is 
usually encoded in lines of text, with each row consisting of a series of tab-delimited 
values.
These files are easy to view and interpret and can be processed on 
any platform with the minimum of library dependencies. Using compression,
text files can be quite compact, and Tabix~\citep{li11} provides  
fast retrieval of rows from arbitrary locations in the table.

It is not sufficient, however, to simply store and retrieve data. To use data
it must be \emph{processed}. This is the major flaw in 
using text files as a data format: before we can perform calculations, we 
must first parse the encoded information into native 
machine values. This is an expensive process, and 
compression (if it is used) adds another substantial overhead. The result 
of this is that simple calculations over a large dataset may take 
many hours to complete.

Another problem with tables stored text files is that it is difficult 
to index the information within particular columns. 
This means that most operations on the table require a complete scan 
through the file. As a result, the only viable means of 
working with a subset of the data
is to create another file consisting of the subset of interest. 
This is inflexible and error prone, and multiplies already significant  
storage requirements.

The obvious solution to these problems is to load tabular data into a
relational database. Databases store values in binary form so that parsing is 
not required, and support efficient retrieval and indexing. There 
are many problems with this approach, however. Relational databases are 
extremely complex systems, each supporting different features and SQL 
dialects. It is not a straightforward task to design a schema for a 
particular data set, particularly not if portability across different 
databases is required. Similarly, accessing the data requires a knowledge
of SQL. In the most common case, a database server must also be maintained
and so storage and user permissions must be carefully managed. All of 
these aspects require significant expertise.

A relational database server, however, is far more than we require in the 
majority of cases. Data files are usually written once and 
not subsequently expected to change.
Thus, storing this information 
in a relational database with its sophisticated concurrency control
is entirely unnecessary. Centralised storage of data sets
creates an unnecessary administration burden, as does an extra
layer of user management. Therefore, although relational databases
provide powerful data management technologies, they are complex
to use and maintain and are therefore rarely used for 
static datasets.

\section{Wormtable}
% what is wormtable?
Wormtable (write-once read-many table) 
is a new data format and software library designed specifically
to deal with the challenges of data processing in bioinformatics.
It provides a portable, compact, read-only store for tabular
data of essentially unlimited size. Tables can
be either written directly via the library, or converted
from existing formats via command line tools. 
Wormtable provides a simple Python API to access rows
in the table, facilitating efficient and convenient access to 
data.

% Wormtable's binary row format 
Data is stored using a  
compact binary format designed specifically for biological applications.
Each row consists of a fixed number of columns, and each column 
holds either a fixed or variable number of elements of a fixed type and size.
Wormtable currently supports signed and unsigned integers, 
floating point and character data. To ensure that values are 
stored as compactly as possible, integer sizes can range from  
$1$ to $8$ bytes. The standard single and double precision 
floating point values are also supported, along with fixed and 
variable length strings.

% why do we use Berkeley DB?
To take advantage of the data processing capabilities of database
technologies without the overheads and disadvantages of relational databases,
wormtable uses Berkeley DB~\citep{obs99} for row storage and indexing.
Berkeley DB is a free and open-source embedded database toolkit that provides a
scalable key-value store. It is a mature and stable platform, 
and is currently the most widely deployed database toolkit in the 
world~\citep{sb12}. Berkeley DB is a highly modular library, providing the 
means to define a very lightweight read-only database, without the 
overheads and complexity of a relational database system.

In wormtable, each table corresponds to a directory in the file system
which is used to store the table, indexes and metadata.
Indexes over arbitrary combinations of columns are supported, 
and these are managed using the \texttt{wtadmin} program, which 
provides several other administration utilities.
Wormtable files are portable across operating systems 
and processor architectures.

\section{Examples}
The Variant Call Format (VCF) encodes information about variant sites in a genome 
as tab-delimited rows in a text file~\citep{da+11}.  
To illustrate the advantages of wormtable, we
converted a large 
publicly available VCF file, produced as part of the
Drosophila genetic reference panel~\citep{mr+12}, to wormtable format.
This VCF\footnote{\href%
{ftp://ftp.hgsc.bcm.edu/DGRP/freeze2\_Feb\_2013/vcf\_files/freeze2.vcf.gz}
{ftp://ftp.hgsc.bcm.edu/DGRP/freeze2\_Feb\_2013/vcf\_files/freeze2.vcf.gz}}
consists of 15GB of uncompressed text and contains data from the 
whole genome over 6,146,611 rows.
Using the included \texttt{vcf2wt} program
the VCF was converted to wormtable format 
on a standard workstation with a single hard disk. The
conversion required approximately 68 minutes, and the size of the resulting  
wormtable file was 10.1GB (using the smallest type required
to represent the data in each column).

Values are stored in wormtable in a portable binary format, so that no parsing is
required when reading in rows. To illustrate this advantage, we
wrote a script to count the number of transitions and transversions
in the dataset using wormtable and PyVCF\footnote{%
\href{http://pyvcf.rtfd.org/}{http://pyvcf.rtfd.org/}}, 
a Python VCF parser.
In this example we proceed 
row-by-row, examining the REF and ALT columns and
counting the transitions and transversions we encounter. 
Using PyVCF this required approximately 126 minutes;
the wormtable version required
55 seconds. To compare against methods that are known to be extremely
efficient, we repeated the same 
example using the Unix tools \texttt{cut}, \texttt{grep} 
and \texttt{awk},  which required 77 seconds. Both the
Unix pipeline and wormtable were limited by the sequential read
bandwidth of the hard drive, and would therefore be much 
faster using modern solid state storage.
It should be noted, however, that this simple task represents 
something of a best case scenario for the Unix tools pipeline.

Another major advantage of wormtable is the ability to create 
an index over arbitrary combinations of columns within a table.
Indexes make many operations much more efficient, as they provide 
a way to quickly find particular rows and avoid the 
heavy cost of a full table scan.
To illustrate this advantage, we repeated the example 
of counting transitions and transversions using an index 
on the REF and ALT columns.
The index required 3m42s to build and 
consumed 66MB of storage space. Counting the number of 
transitions and transversions using this index required 
less than a second.

\section{Conclusions}
It is well known that parsing text files is a very inefficient process, 
and binary file formats are preferable for this reason. The BCF format,
for example, is a binary version of the VCF format discussed above which 
is designed to avoid just this problem. There are significant difficulties,
however, with having many different binary file formats for bioinformatics 
data. Each binary format requires a library and set of tools to view 
and process it, as it is not reasonable to expect users to decode binary
files. Bindings for several different languages must also be provided, if 
the file format is to be widely used.
Maintaining these libraries, tools and language bindings across 
different processor architectures and operating systems
is a complex software engineering task. Maintaining this ecosystem 
separately for several different file formats is surely 
unsustainable.

Wormtable alleviates the need for these different formats and libraries,
as it is flexible enough to store many different types of data. Python 
is currently the only programming language supported, but a C library
and bindings for other languages are planned. Wormtable is portable,
and has been tested on big- and little-endian platforms with 32 and 64
bit word sizes, along with many operating system combinations. To 
take advantage of the advanced data processing features of wormtable
all that is required is a conversion program, a considerably simpler
task than designing and supporting a custom binary file format.

Wormtable is not intended to replace text files as the universal 
interchange format for biological data. 
It is intended to provide a persistent data structure 
that can be efficiently processed 
and searched. Using this data structure, researchers with no knowledge of 
database systems can take full advantage of sophisticated 
data management techniques, and write simple code to process 
data in a high performance manner. 
Different file formats can be handled consistently 
in wormtable, reducing the need for third party libraries 
to parse complex files and simplifying the code required 
to process data.
Together, these advantages of increased performance and reduced 
code complexity can substantially increase a researcher's 
productivity and ability to explore their data.

% If we get some help, it could be pretty awesome...
Wormtable is an open and collaborative project seeking feedback and 
contributors. The project is in its early stages, currently 
providing a conversion tool for the VCF format only. With community
participation it may grow to support many other formats and become
a powerful common platform for bioinformatics data analysis.

\section*{Acknowledgement}
We would like to thank the Ashworth Codemonkeys for valuable feedback on earlier
versions of wormtable.
\paragraph{Funding\textcolon}  
JK is supported by EPSRC grant EP/I013091/1.

\bibliographystyle{plainnat}
\bibliography{paper}

\end{document}
