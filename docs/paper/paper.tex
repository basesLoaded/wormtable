%% BioMed_Central_Tex_Template_v1.05
%%                                      %
%  bmc_article.tex            ver: 1.05 %
%                                       %


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                     %%
%%  LaTeX template for BioMed Central  %%
%%     journal article submissions     %%
%%                                     %%
%%         <27 January 2006>           %%
%%                                     %%
%%                                     %%
%% Uses:                               %%
%% cite.sty, url.sty, bmc_article.cls  %%
%% ifthen.sty. multicol.sty		       %%
%%									   %%
%%                                     %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                 %%	
%% For instructions on how to fill out this Tex template           %%
%% document please refer to Readme.pdf and the instructions for    %%
%% authors page on the biomed central website                      %%
%% http://www.biomedcentral.com/info/authors/                      %%
%%                                                                 %%
%% Please do not use \input{...} to include other tex files.       %%
%% Submit your LaTeX manuscript as one .tex document.              %%
%%                                                                 %%
%% All additional figures and files should be attached             %%
%% separately and not embedded in the \TeX\ document itself.       %%
%%                                                                 %%
%% BioMed Central currently use the MikTex distribution of         %%
%% TeX for Windows) of TeX and LaTeX.  This is available from      %%
%% http://www.miktex.org                                           %%
%%                                                                 %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\NeedsTeXFormat{LaTeX2e}[1995/12/01]
\documentclass[10pt]{bmc_article}    



% Load packages
\usepackage{cite} % Make references as [1-4], not [1,2,3,4]
\usepackage{url}  % Formatting web addresses  
\usepackage{ifthen}  % Conditional 
\usepackage{multicol}   %Columns
\usepackage[utf8]{inputenc} %unicode support
%\usepackage[applemac]{inputenc} %applemac support if unicode package fails
%\usepackage[latin1]{inputenc} %UNIX support if unicode package fails
\urlstyle{rm}
 
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	
%%                                             %%
%%  If you wish to display your graphics for   %%
%%  your own use using includegraphic or       %%
%%  includegraphics, then comment out the      %%
%%  following two lines of code.               %%   
%%  NB: These line *must* be included when     %%
%%  submitting to BMC.                         %% 
%%  All figure files must be submitted as      %%
%%  separate graphics through the BMC          %%
%%  submission process, not included in the    %% 
%%  submitted article.                         %% 
%%                                             %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                     


\def\includegraphic{}
\def\includegraphics{}



\setlength{\topmargin}{0.0cm}
\setlength{\textheight}{21.5cm}
\setlength{\oddsidemargin}{0cm} 
\setlength{\textwidth}{16.5cm}
\setlength{\columnsep}{0.6cm}

\newboolean{publ}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                              %%
%% You may change the following style settings  %%
%% Should you wish to format your article       %%
%% in a publication style for printing out and  %%
%% sharing with colleagues, but ensure that     %%
%% before submitting to BMC that the style is   %%
%% returned to the Review style setting.        %%
%%                                              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 

%Review style settings
\newenvironment{bmcformat}{\begin{raggedright}\baselineskip20pt\sloppy\setboolean{publ}{false}}{\end{raggedright}\baselineskip20pt\sloppy}

%Publication style settings
%\newenvironment{bmcformat}{\fussy\setboolean{publ}{true}}{\fussy}



% Begin ...
\begin{document}
\begin{bmcformat}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                          %%
%% Enter the title of your article here     %%
%%                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Processing genome scale tabular data with wormtable}
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                          %%
%% Enter the authors here                   %%
%%                                          %%
%% Ensure \and is entered between all but   %%
%% the last two authors. This will be       %%
%% replaced by a comma in the final article %%
%%                                          %%
%% Ensure there are no trailing spaces at   %% 
%% the ends of the lines                    %%     	
%%                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\author{Jerome Kelleher\correspondingauthor%
       \email{Jerome Kelleher\correspondingauthor - jerome.kelleher@ed.ac.uk}%
      \and
         Rob W Ness
         \email{Rob W Ness - rob.ness@ed.ac.uk}%
       and 
         Daniel L Halligan%
         \email{Daniel L Halligan - dan.halligan@gmail.com}%
      }
      

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                          %%
%% Enter the authors' addresses here        %%
%%                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\address{%
    University of Edinburgh, King's Buildings, West Mains Road, %
        EH9 3JT, UK}%

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                          %%
%% The Abstract begins here                 %%
%%                                          %%
%% The Section headings here are those for  %%
%% a Research article submitted to a        %%
%% BMC-Series journal.                      %%  
%%                                          %%
%% If your article is not of this type,     %%
%% then refer to the Instructions for       %%
%% authors on http://www.biomedcentral.com  %%
%% and change the section headings          %%
%% accordingly.                             %%   
%%                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{abstract}
        % Do not use inserted blank lines (ie \\) until main body of text.
\paragraph*{Background:} 
Biological research generates large amounts of tabular data.
These tables are produced by 
programs and exported to plain text files, which are often very large. 
Researchers must process these files 
line-by-line, parsing values encoded as text into native types so that 
calculations may be done. This is a time consuming process.
Furthermore, there is no simple means of indexing these files so that 
rows containing particular values can be quickly found. 
\paragraph*{Results:} 
We introduce a new 
data format and software library called wormtable, which provides efficient 
access to tabular data in Python. Wormtable stores data in a compact
binary format, provides random access to rows, and enables sophisticated
indexing on columns within these tables. Files written in existing 
formats can be easily converted to wormtable format, and we 
provide conversion utilities for the VCF and GTF format.

\paragraph*{Conclusions:} Using wormtable's simple API users 
can process tables in a very high performance manner, allowing them
much greater freedom to explore their data. 
Since it is no longer necessary to parse complex files,
data analysis code is also much simpler and less error prone. 
\end{abstract}



\ifthenelse{\boolean{publ}}{\begin{multicols}{2}}{}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                          %%
%% The Main Body begins here                %%
%%                                          %%
%% The Section headings here are those for  %%
%% a Research article submitted to a        %%
%% BMC-Series journal.                      %%  
%%                                          %%
%% If your article is not of this type,     %%
%% then refer to the instructions for       %%
%% authors on:                              %%
%% http://www.biomedcentral.com/info/authors%%
%% and change the section headings          %%
%% accordingly.                             %% 
%%                                          %%
%% See the Results and Discussion section   %%
%% for details on how to create sub-sections%%
%%                                          %%
%% use \cite{...} to cite references        %%
%%  \cite{koon} and                         %%
%%  \cite{oreg,khar,zvai,xjon,schn,pond}    %%
%%  \nocite{smith,marg,hunn,advi,koha,mouse}%%
%%                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%
%% Background %%
%%
\section*{Background} 

\emph{The Background section should be written in a
way that is accessible to researchers without specialist knowledge in
that area and must clearly state - and, if helpful, illustrate - the
background to the research and its aims. It should clearly described the
relevant context and the specific issue which the software described is
intended to address.}

Despite the ever increasing volumes of data being processed in bioinformatics,
the methods used are almost entirely based on plain text files. Data is 
usually encoded in lines of text, with each row consisting of a series of tab-delimited 
values.
These files are easy to view and interpret and can be processed on 
any platform with the minimum of library dependencies. Using compression,
text files can be quite compact, and Tabix~\cite{li11} provides  
fast retrieval of rows from arbitrary locations in the table.

It is not sufficient, however, to simply store and retrieve data. To use data
it must be \emph{processed}. This is the major flaw in 
using text files as a data format: before we can perform calculations, we 
must first parse the encoded information into native 
machine values. This is an expensive process, and 
compression (if it is used) adds another substantial overhead. The result 
of this is that simple calculations over a large dataset may take 
many hours to complete.

Another problem with tables stored as text files is that it is difficult 
to index the information within particular columns. 
This means that many operations on a table require a complete scan 
through the file. As a result, the only viable means of 
working with a subset of the data
is to create another file consisting of the subset of interest. 
This is inflexible and error prone, and multiplies already significant  
storage requirements.

The obvious solution to these problems is to load tabular data into a
relational database. Databases store values in binary form so that parsing is 
not required, and support efficient retrieval and indexing. There 
are many problems with this approach, however. Relational databases are 
extremely complex systems, each supporting different features and SQL 
dialects. It is not a straightforward task to design a schema for a 
particular data set, particularly not if portability across different 
databases is required. Similarly, accessing data requires a knowledge
of SQL. In the most common case, a database server must also be maintained
and so storage and user permissions must be carefully managed. All of 
these aspects require significant expertise.

A relational database server, however, is far more than we require in the 
majority of cases. Data files are usually written once and 
not subsequently expected to change.
Thus, storing this information 
in a relational database with its sophisticated concurrency control
is entirely unnecessary. Centralised storage of data sets
creates an unnecessary administration burden, as does an extra
layer of user management. Therefore, although relational databases
provide powerful data management technologies, they are complex
to use and maintain and are therefore rarely used for 
static datasets.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Implementation 
%%
\section*{Implementation}
\emph{This should include a description of the overall architecture of the software implementation, 
along with details of any critical issues and how they were addressed.
}

% what is wormtable?
Wormtable (write-once read-many table) 
is a new data format and software library designed specifically
to deal with the challenges of data processing in bioinformatics.
It provides a portable, compact, read-only store for tabular
data of essentially unlimited size. Tables can
be either written directly via the library, or converted
from existing formats via command line tools. 
Wormtable provides a simple Python API to access rows
in the table, facilitating efficient and convenient access to 
data. The core data manipulation and storage facilities 
are written in C for efficiency.

% Wormtable's binary row format 
Data is stored in rows using a  
compact binary format designed specifically for biological applications.
Each row consists of a fixed number of columns, and each column 
holds either a fixed or variable number of elements of a fixed type and size.
Wormtable currently supports signed and unsigned integers, 
floating point and character data. To store data as 
compactly as possible, integer sizes range from one to eight bytes,
and real numbers are stored as IEEE half, single, and double 
precision floating point values. 
Fixed and variable length character strings 
are also supported. 

% Tables
Rows are stored sequentially in a data file, and the offset and length 
of each row is stored in a Berkeley DB~\cite{obs99} database. 
Thus, any given row can be found 
by first looking up the database for its offset and length, and by then reading
the required set of bytes from the data file. 
Berkeley DB is a free and open-source embedded database toolkit that provides a
scalable key-value store. It is a mature and stable platform, 
and is currently the most widely deployed database toolkit in the 
world~\cite{sb12}. 

% Indexes
Besides random access to rows, wormtable also provides indexes
over arbitrary combinations of columns. An index is a database in 
which the keys are the values from the columns in question concatenated
together, and the values are pointers to the original row. Indexes make
many operations much more efficient, since we can directly seek to the 
rows we are interested in without performing a full table scan. They also 
provide a very efficient means of calculating a histogram for a given 
set of columns. Wormtable also supports binned indexes, in which a range of 
values is mapped to a single index key. This is very useful for floating 
point columns, where it may not be necessary to distinguish between
values that differ by small amounts.

% Layout 
Each table corresponds to a directory in the file system
which is used to store the data files, indexes and metadata.
Files within a table's home directory are not intended to be 
manipulated by users, and the \texttt{wtadmin} program is provided 
to perform administration tasks such as adding and removing 
indexes. This approach is 
very flexible, since no centralised storage is required and 
tables can be moved around and between systems at will.
Tables are portable across operating systems and hardware
architectures.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Results and Discussion %%
%%
\section*{Results}

\emph{The Results and Discussion may be combined into a single section or
presented separately. They may also be broken into subsections with
short, informative headings. In any case what should be described is the
functionality of the software together with data on how its performance
and functionality compare with and improve on functionally similar
existing software. There should then be a discussion of the intended
use of the software, and the benefits that are envisioned together,
if possible, with an outline for the planned future development of
new features.}

\subsection*{API}
The principle goal of wormtable is to provide efficient access to data 
using an easy to learn interface. 
The \texttt{Table} class provides the main interface,
and implements the standard Python sequence protocols. Efficient 
iteration over rows is provided by the \texttt{cursor} method, 
which takes as an argument the list of columns to read.
Only the values for the columns 
of interest are then retrieved, leading to considerable
time savings. The \texttt{cursor} function takes two additional 
arguments, \texttt{start} and \texttt{stop}, which specify 
rows of interest. This allows us to efficiently seek to an 
arbitary location in the table and to read a given number 
of rows sequentially from this point.

The \texttt{Index} class also has a \texttt{cursor} function
with the same signature, but in this case, rows 
are returned in the order defined by the index. The  
\texttt{start} and \texttt{stop} arguments are now defined 
in terms of index keys: all rows in which the index key
is greater than or equal to \texttt{start} and less 
than \texttt{stop} are returned. Partial keys may also be 
provided for multi-column indexes. The \texttt{Index} 
class also provides an iterator over all keys, as well 
as a means of counting the number of rows with a given 
key.

The API is straightforward, but it is flexible, powerful and 
extensible. This simplicity ensures that 
programmer of all experience levels  
can take full advantage of the powerful data 
processing that wormtable provides. In the following subsections 
we illustrate the performance advantages of wormtable via some 
examples. These are not intended to be definitive benchmarks
and are simply concrete examples to demonstrate the type of improvements 
that can be expected by using wormtable over existing methods.

\subsection*{Scan performance}
The Variant Call Format (VCF) encodes information about variant sites in a genome 
as tab-delimited rows in a text file~\cite{da+11}.  
To illustrate the advantages of wormtable when performing calculations over 
a whole table, we converted a large 
publicly available VCF file (produced as part of the
Drosophila genetic reference panel~\cite{mr+12}) to wormtable format.
This VCF\cite{freeze.vcf}
consists of 15GB of uncompressed text and contains data from the 
whole genome over 6,146,611 rows.
Using the included \texttt{vcf2wt} program
the VCF was converted to wormtable format 
on a workstation with an Intel Xeon processor, 12GB of RAM 
and a single hard disk. The
conversion required approximately 69 minutes, and the size of the resulting  
wormtable was 10GB (using the smallest type required
to represent the data in each column).

Values are stored in wormtable in a portable binary format, so that no parsing is
required when reading in rows. To illustrate this advantage, we
wrote a script to count the number of transitions and transversions
in the dataset using wormtable and PyVCF~\cite{pyvcf}
a Python VCF parser.  In this example we proceed 
row-by-row, examining the REF and ALT columns and
counting the transitions and transversions we encounter. 
Using PyVCF this required approximately 126 minutes, whereas 
the wormtable version required
57 seconds. To compare against methods that are known to be extremely
efficient, we repeated the same 
example using the Unix tools \texttt{cut}, \texttt{grep} 
and \texttt{awk},  which required 80 seconds. Both the
Unix pipeline and wormtable were limited by the sequential read
bandwidth of the hard drive, and would therefore be much 
faster using modern solid state storage.
It should be noted, however, that although Unix 
pipelines are efficient, it is a difficult and error prone method 
of processing data when more complex calculations are required.

Full table scans are often uneccessary in wormtable. For many tasks,
creating an appropriate index allows us to seek directly to the 
rows of interest. To illustrate this, we repeated the example 
of counting transitions and transversions using an index 
on the REF and ALT columns.
The index required 3m40s to build and 
consumed 66MB of storage space. Counting the number of 
transitions and transversions using this index required 
less than a second.

\subsection*{Seek performance}
One of the most serious problems with tabular data stored in text files
is that it is not possible to access a particular row 
efficiently without some auxiliary 
index. Unless we have some information on where a particular row is located
in a file, there is little that can be done except to read the file 
line-by-line until the required row is found. Tabix~\cite{li11} solves
this problem by compressing a tab-delimited text file into blocks, and 
then storing an index mapping genome position to the location 
of the compressed block, and the position of the row within the block.
Tabix is specifically designed for range queries, allowing us to 
efficiently retrieve all of the rows within a given genomic range.

To compare the seek performance of wormtable with Tabix, we compressed
the VCF file mentioned in the previous subsection using \texttt{bgzip}
and indexed it with \texttt{tabix}. Since the VCF file was not 
strictly in order of genome position (in violation of the VCF format),
we first needed to sort the VCF file, which required 5m13s. Afterwards,
compression required 11m8s, and indexing with \texttt{tabix} required
1m12s. The size of the resulting compressed file was 2.9GB and 
the size of the index file was 106KB.
To duplicate the functionality of Tabix on VCF data, we simply need to 
create an index on the CHROM and POS columns using \texttt{wtadmin add}. 
This required approximately
2 minutes and the resulting index consumed 115MB of space.

We compared the seek performance of Tabix and wormtable by generating 
a genomic location randomly and retrieving all rows within 1Kb of
this location. This 
was repeated $10^4$ times, and we measured both the elapsed and 
processor time. The Tabix Python module was used for the 
comparison, ensuring that no overheads associated with process 
forking were incurred. The same set of random locations were used 
for wormtable and Tabix, ensuring a fair comparison.

When using a cold cache (i.e., no pages of the files in question are 
present in the operating system's cache) the elapsed
time for Tabix was 103 seconds with a processor time of 65
seconds. For wormtable, the elapsed time was 181 seconds 
with a processor time of 5 seconds. Thus, the time required 
to perform this test is dominated by waiting for I/O in both 
cases. Since the wormtable file is considerably larger than the 
compressed file used by Tabix, more and larger seeks were required 
to bring the required pages into memory. However, once the 
pages were in memory, Tabix needed to do much more work to 
decompress then and make them usable, as shown by the 
difference in processor times.

This difference is well illustrated by immediately repeating 
the same experiment, so that all the relevent pages are 
in cache. In this case, the elapsed time was 56 seconds for Tabix and around 
2 seconds for wormtable. Thus, compression is a double-edged sword: 
it does lead to much smaller files, which reduces the number of random seeks 
required.  On the other hand, however, decompression is expensive and must 
be repeated each time a block is accessed unless some sophisticated
caching mechanism is devised. 

The penalty for random seeks is exceedingly high in this 
example, however, since we have used a hard disk for storage.
Repeating the cold cache example on a laptop equipped with 
solid state storage, the elapsed time for Tabix was 76 seconds
with a CPU time of 72 seconds, whereas the elapsed time for 
wormtable was 31 seconds with a CPU time of 6.5 seconds. Thus, using 
solid state storage negates the advantage of smaller files, since 
seeks are much less expensive.  
 With the rapidly reducing cost and 
increasing capacity of solid state storage, it seems likely 
that it will soon be routinely used for all but the largest 
of bulk storage. Wormtable takes much better advantage of
modern hardware and large cache sizes, allowing the full bandwidth 
and random seek performance to be utilised. Compression based 
techniques will always be limited by the CPU time required to 
decompress data.


\section*{Discussion}
The problems of enabling efficient random access to rows and 
avoiding the large overhead of parsing text are well understood, 
and efforts to address them are proceeding in parallel for 
different file formats. 
BCF, for example, is the binary version of the VCF format discussed 
above, in which values within rows are stored in a packed binary 
format.  Similiarly, BigBed and 
BigWig~\cite{kzbhk10} are compressed binary versions of the BED 
and WIG file formats, which offer efficient random access along 
with the ability to operate over a network. 

There are significant difficulties,
however, with having many different binary file formats for bioinformatics 
data. Each binary format requires a library and set of tools to view 
and process it, as it is not reasonable to expect users to decode binary
files. Bindings for several different languages must also be provided, if 
the file format is to be widely used.
Maintaining these libraries, tools and language bindings across 
different processor architectures and operating systems
is a complex software engineering task. Maintaining this ecosystem 
separately for many different file formats is surely 
unsustainable.

Wormtable alleviates the need for these different formats and libraries,
as it is flexible enough to store many different types of data. Wormtable is portable,
and has been tested on big- and little-endian platforms with 32 and 64
bit word sizes, along with many operating system combinations. To 
take advantage of the advanced data processing features of wormtable
all that is required is a conversion program, a considerably simpler
task than designing and supporting a custom binary file format.

The library supports efficient access to any data stored in 
wormtable format, and currently provides conversion utilitites 
for the VCF and GTF formats.
The most important aspect of future development 
is to develop tools to convert other tabular formats such as 
PSL, GFF and BED to wormtable format. Such tools are 
not difficult to develop, since all that is required is a parser
for the format in question written in Python.

Wormtable is currently limited to supporting Python only, and 
another important aspect of future development is to 
develop a C library along with bindings for other popular
languages such as Perl, R and PHP. 
Wormtable does not support interval search, and so it is not
straightforward to find, for example, all rows overlapping 
a given genomic region in GTF files. This problem has been 
solved several times, however, and we aim to adapt existing 
techniques~\cite{li11,kzbhk10} and incorporate them into 
wormtable.  Compression of data can
result in poor performance, but it is often necessary when 
volumes of data are very large. Thus, we plan on introducing 
optional compression of the data file in wormtable in 
a future release. Beyond these additions, it is difficult
predict the precise direction of future development since this depends 
on feedback from the community.  Wormtable is an open and 
collaborative project actively seeking feedback and 
contributors.


%%%%%%%%%%%%%%%%%%%%%%
\section*{Conclusions}
\emph{This should state clearly the main conclusions of the article and give a clear 
explanation of the importance and relevance of the software.}

The volumes of data being produced and processed in bioinformatics are constantly 
increasing, but the tools available to end users to 
process this data are still mostly based on parsing plain text. This 
approach is very inefficient, and leads to several undesirable outcomes.
Firstly, and most obviously, a researcher's productivity is inevitably
reduced by having to wait for several hours to see the result of a 
simple calculation. There are also some less obvious consequences:
code quality is reduced, since testing over the entire dataset is 
infeasible, and it is much less likely that the effects of 
changing arbitrary quality thresholds (for example) will be 
systematically examined.

We have concentrated on the VCF format here since it is a widely 
used and popular format. After converting the VCF format to 
wormtable using \texttt{vcf2wt} a user can process the 
data very efficiently using Python. Accessing data from 
rows in wormtable is many times faster than is possible 
by parsing rows encoded as text.
This is also a very convenient 
way to access VCF data, since individual columns are already 
parsed and all that is needed is the name of the columns of 
interest. For accessing regions of the genome efficiently
the user simply needs to create an index on the CHROM and POS columns
using the  \texttt{wtadmin add} command, and can then efficiently
seek to arbitrary locations. In the worst case, when using a 
slow hard disk this is somewhat slower than Tabix. In the best
case, when frequently accessing the same regions or using 
fast solid state storage, wormtable is many times faster than 
Tabix. Moreover, wormtable is much more general than Tabix, 
since it can index any column or combination of columns.
Similarly, wormtable is not limited to VCF, but can store
any form of fixed tabular data. We also provide a conversion 
tool for the GTF format, and several others are planned.

Wormtable is not intended to replace text files as the universal 
interchange format for biological data. 
It is intended to provide a persistent data structure 
that can be efficiently processed 
and searched. Using this data structure, researchers with no knowledge of 
database systems can take full advantage of sophisticated 
data management techniques, and write straightforward code to process 
data efficiently. 
Different file formats can be handled consistently 
in wormtable, reducing the need for third party libraries 
to parse complex files and simplifying the code required 
to process data.
Together, these advantages of increased performance and reduced 
code complexity can substantially increase a researcher's 
productivity and ability to explore their data.


  
%%%%%%%%%%%%%%%%%%
\section*{Availability and requirements}
\paragraph{Project name:} Wormtable.
\paragraph{Project home page:}\url{https://pypi.python.org/pypi/wormtable}
\paragraph{Operating system(s):} POSIX.
\paragraph{Programming language:} C, Python.
\paragraph{Other requirements:} Berkeley DB 4.8 or later.
\paragraph{License:} GNU LGPLv3+.
\paragraph{Any restrictions to use by non-academics:} None.

    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Authors contributions}
    Text for this section \ldots


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Acknowledgements}
  \ifthenelse{\boolean{publ}}{\small}{}
We would like to thank the Ashworth Codemonkeys for valuable feedback on earlier
versions of wormtable.  JK is supported by EPSRC grant EP/I013091/1.

 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                  The Bibliography                       %%
%%                                                         %%              
%%  Bmc_article.bst  will be used to                       %%
%%  create a .BBL file for submission, which includes      %%
%%  XML structured for BMC.                                %%
%%                                                         %%
%%                                                         %%
%%  Note that the displayed Bibliography will not          %% 
%%  necessarily be rendered by Latex exactly as specified  %%
%%  in the online Instructions for Authors.                %% 
%%                                                         %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


{\ifthenelse{\boolean{publ}}{\footnotesize}{\small}
 \bibliographystyle{bmc_article}  % Style BST file
  \bibliography{paper.bib} }     % Bibliography file (usually '*.bib' ) 

%%%%%%%%%%%

\ifthenelse{\boolean{publ}}{\end{multicols}}{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               %%
%% Figures                       %%
%%                               %%
%% NB: this is for captions and  %%
%% Titles. All graphics must be  %%
%% submitted separately and NOT  %%
%% included in the Tex document  %%
%%                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% Do not use \listoffigures as most will included as separate files


\end{bmcformat}
\end{document}







